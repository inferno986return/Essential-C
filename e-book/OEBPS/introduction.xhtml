<?xml version="1.0" encoding="UTF-8" standalone="no" ?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/>
<link href="styles/zstylesheet.css" rel="stylesheet" type="text/css"/>
<title>Introduction</title>
</head>

<body>
	<h1 class="heading">Introduction</h1>	
	
	<h1 class="subheading">The C Language</h1>
	<p class="noindent">The C Language C is a professional programmer's language. It was designed to get in one's way as little as possible. Kernighan and Ritchie wrote the original language definition in their book, The C Programming Language (below), as part of their research at AT&amp;T. Unix and C++ emerged from the same labs. For several years I used AT&amp;T as my long distance carrier in appreciation of all that CS research, but hearing "thank you for using AT&amp;T" for the millionth time has used up that good will.</p>
	<p>Some languages are forgiving. The programmer needs only a basic sense of how things work. Errors in the code are flagged by the compile-time or run-time system, and the programmer can muddle through and eventually fix things up to work correctly. The C language is not like that.</p>
The C programming model is that the programmer knows exactly what they want to do
and how to use the language constructs to achieve that goal. The language lets the expert
programmer express what they want in the minimum time by staying out of their way.
C is "simple" in that the number of components in the language is small-- If two language
features accomplish more-or-less the same thing, C will include only one. C's syntax is
terse and the language does not restrict what is "allowed" -- the programmer can pretty
much do whatever they want.
C's type system and error checks exist only at compile-time. The compiled code runs in a
stripped down run-time model with no safety checks for bad type casts, bad array indices,
or bad pointers. There is no garbage collector to manage memory. Instead the
programmer mangages heap memory manually. All this makes C fast but fragile.

	<h1 class="subheading">Analysis -- Where C Fits</h1>
Because of the above features, C is hard for beginners. A feature can work fine in one
context, but crash in another. The programmer needs to understand how the features work
and use them correctly. On the other hand, the number of features is pretty small.
Like most programmers, I have had some moments of real loathing for the C language. It
can be irritatingly obedient -- you type something incorrectly, and it has a way of
compiling fine and just doing something you don't expect at run-time. However, as I have
become a more experienced C programmer, I have grown to appreciate C's straight-to-the
point style. I have learned not to fall into its little traps, and I appreciate its simplicity.
Perhaps the best advice is just to be careful. Don't type things in you don't understand.
Debugging takes too much time. Have a mental picture (or a real drawing) of how your C
code is using memory. That's good advice in any language, but in C it's critical.
Perl and Java are more "portable" than C (you can run them on different computers
without a recompile). Java and C++ are more structured than C. Structure is useful for
large projects. C works best for small projects where performance is important and the
progammers have the time and skill to make it work in C. In any case, C is a very popular
and influential language. This is mainly because of C's clean (if minimal) style, it's lack
of annoying or regrettable constructs, and the relative ease of writing a C compiler.

	<h1 class="subheading">Other Resources</h1>
	
	<ul>
		<li><i>The C Programming Language</i>, 2nd ed., by Kernighan and Ritchie. The thin book which for years was the bible for all C programmers. Written by the original designers of the language. The explanations are pretty short, so this book is better as a reference than for beginners.</li>
		<li><a href="http://cslibrary.stanford.edu/102/">Pointers and Memory</a> -- Much more detail about local memory, pointers, reference parameters, and heap memory than in this article, and memory is really the hardest part of C and C++.</li>
		<li><a href="http://cslibrary.stanford.edu/103/">Linked List Basics</a> -- Once you understand the basics of pointers and C, these problems are a good way to get more practice.</li>
	</ul>

</body>
</html>
